#!/usr/bin/env python
# Echo server, multiplexed using select
# Since this doesnt use multithreading/multiprocessing, some operations
# must be non-blocking
# Based on https://pymotw.com/2/select/

import select
import socket
import sys
import Queue

HOST = "0.0.0.0"
PORT = 8000
SERVER_ADDR = (HOST, PORT)

tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcpSocket.setblocking(0)
tcpSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

print >>sys.stderr, "Starting up on %s port %s" % SERVER_ADDR
tcpSocket.bind(SERVER_ADDR)
tcpSocket.listen(5)

# Sockets from which we expect to read
inputs = [ tcpSocket ]
# Sockets to which we expect to write
outputs = [ ]
# Outgoing message queues
message_queues = {}

while inputs:
	print >>sys.stderr, "\nWaiting for the next event"
	readable, writable, exceptional = select.select(inputs, outputs, inputs)

	# Handle inputs
	for s in readable:
		if s is tcpSocket:
			# A readable server socket is ready to accept a connection
			connection, client_address = tcpSocket.accept()
			print >>sys.stderr, "Client connected! From ", client_address
			connection.send("Connection established!\n")
			connection.setblocking(0)
			inputs.append(connection)

			# Give connection a queue for outgoing data
			message_queues[connection] = Queue.Queue()
		else:
			# This case is for connections made to client
			data = s.recv(2048)
			if data:
				print >>sys.stderr, "Received '%s' from %s" % (data, s.getpeername())
				message_queues[s].put(data)
				# Add output channel for response
				if s not in outputs:
					outputs.append(s)
			else:
				# Interpret empty result as closed connection
				print >>sys.stderr, "Closing ", s.getpeername()
				# Stop listening
				if s in outputs:
					outputs.remove(s)
				if s in writable:
					writable.remove(s)
				inputs.remove(s)
				s.close()
				del message_queues[s]

	# Handle outputs
	for s in writable:
		try:
			next_msg = message_queues[s].get_nowait()
		except Queue.Empty:
			# No message waiting so stop checking for writeability
			print >>sys.stderr, "Output queue for", s.getpeername(), "is empty"
		except:
			print "Unexpected error: ", sys.exc_info()[0]
		else:
			print >>sys.stderr, "Sending '%s' to %s" % (next_msg, s.getpeername())
			s.send(next_msg)

	# Handle exceptional condition (close connection)
	for s in exceptional:
		print >>sys.stderr, "Handling exceptional condition for %s" % s.getpeername()
		# Stop listening for input on the connection
		inputs.remove(s)
		if s in outputs:
			outputs.remove(s)
		s.close()
		del message_queues[s]

