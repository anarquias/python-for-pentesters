#!/usr/bin/env python
# Simple packet sniffer that parses TCP packets and presents individual fields
# Over IPv4
# Run this as root!
#
# IP Header diagram:
#   https://nmap.org/book/images/hdr/MJB-IP-Header-800x576.png
# TCP Header diagram:
#   https://nmap.org/book/images/hdr/MJB-TCP-Header-800x564.png

import binascii
import ctypes
import socket
import struct

c_uint8 = ctypes.c_uint8

# Convenient way of storing TCP Flags
class Tcp_flags_bits(ctypes.LittleEndianStructure):
	_fields_ = [
		("C",	c_uint8, 1),
		("E",	c_uint8, 1),
		("U",	c_uint8, 1),
		("A",	c_uint8, 1),
		("P",	c_uint8, 1),
		("R",	c_uint8, 1),
		("S",	c_uint8, 1),
		("F",	c_uint8, 1)
	]

class Tcp_flags(ctypes.Union):
	_fields_ = [
		("b",		Tcp_flags_bits),
		("asByte",	c_uint8)
	]
	_anonymous_ = ("b")

big_line = "================================================================"

# Use packet interface, raw socket, tell kernel we want to use protocol 0x0800 = IP
# See /usr/include/linux/if_ether.h
rawSocket = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.htons(0x0800))

while True:
	pkt = rawSocket.recvfrom(2048)

	##########################################
	# IP Info 
	##########################################
	raw_ip_header = pkt[0][14:34] # IP Header is 20 bytes

	# Unpack to tuple, like: 
	# ('\x45', '\x00\x00Y\xde\x82@\x00\xff', 17, '\xf9\xff', '\xc0\xa8\x01m', '\xe0\x00\x00\xfb')
	# In order, we're interested in IHL (second nybble of first byte), ignore next 8 bytes (TOS,
	# length, id, flags, fragment offset, TTL), protocol (1 byte), checksum (2 bytes), source
	# ip (4 bytes), dest ip (4 bytes)
	ip_header = struct.unpack("!B8sB2s4s4s", raw_ip_header)

	protocol = ip_header[2]	# 9th byte indicates protocol
	if protocol != 6:
		#Skip if not TCP (protocol ID of TCP is 6)
		continue
	ihl = (ip_header[0] & 0x0F)*4	# IHL - Header length in words (1 nybble)
	
	print big_line
	print "[IP] Source: " + socket.inet_ntoa(ip_header[4]),
	print ", Destination: " + socket.inet_ntoa(ip_header[5])

	##########################################
	# TCP Info
	##########################################

	raw_tcp_header = pkt[0][14+ihl:54] # Beginning of TCP Header computed using IHL

	# Unpack to tuple, like: (55101, 1900, 7202615, 1294816069, 65, 82, 17224, 8234, 8264)
	# Source port (2 bytes), dest port (2 bytes), seq num (4 bytes), ack num (4 bytes)
	# Offet (nybble), reserved (nybble), TCP Flags C E U A P R S F (1 bit ea, 1 byte total)
	# Window (2 bytes), Checksum (2 bytes), Urgent pointer (2 bytes)
	try:
		tcp_header = struct.unpack("!HHIIBBHHH", raw_tcp_header)
	except struct.error:
		print "Error while attempting to unpack tcp header!"
		print "".join(c.encode('hex') for c in raw_tcp_header)
		continue

	src_port = tcp_header[0]	# Source port (2 bytes)
	dst_port = tcp_header[1]	# Destination port (2 bytes)
	seq_num = tcp_header[2]		# Sequence number (4 bytes)
	ack_num = tcp_header[3]		# Acknowledgement number (4 bytes)
	offset = (tcp_header[4] >> 4)*4	# Offset - header length in words (1 nybble)
	reserved = tcp_header[4] & 0x0F	# Reserved (1 nybble)
	flags = Tcp_flags()
	flags.asByte = tcp_header[5]	# TCP Flags (1 bit each for C E U A P R S F)
	window_size = tcp_header[6]	# Window (2 bytes)
	checksum = tcp_header[7]	# Checksum (2 bytes)
	urgent_pointer = tcp_header[8]	# Urgent pointer (2 bytes)

	print "Source Port: " + str(src_port)
	print "Destination Port: " + str(dst_port)
	print "Sequence Number: " + str(seq_num)
	print "Acknowledgement number: " + str(ack_num)
	print "Header length: " + str(offset) + " bytes"
	print "Reserved: " + "{0:b}".format(reserved)
	print "Flags: "
	print "  " + str(flags.C) + "....... Congestion Window Reduced (CWR)"
	print "  ." + str(flags.E) + "...... ECN Echo (ECE)"
	print "  .." + str(flags.U) + "..... Urgent"
	print "  ..." + str(flags.A) + ".... Ack"
	print "  ...." + str(flags.P) + "... Push"
	print "  ....." + str(flags.R) + ".. Reset"
	print "  ......" + str(flags.S) + ". Syn"
	print "  ......." + str(flags.F) + " Fin"
	print "Window size: " + str(window_size)
	print "Checksum: " + "0x{:04X}".format(checksum)

	# Do we have options? Min header size is 20 bytes. >20 means we may have options
	if offset > 20:
		options_size = offset - 20
		raw_tcp_options = pkt[0][54:54+options_size]
		print "TCP Options: " + "".join(c.encode('hex') for c in raw_tcp_options)
		
		i = 0
		while i < len(raw_tcp_options):
			kind = raw_tcp_options[i]
			if kind == "\x01":
				print "  NOP"
			elif kind == "\x08":
				length = raw_tcp_options[i+1] # Length should be 10
				ts_val = struct.unpack("I", raw_tcp_options[i+2:i+6])[0]
				ts_ecr = struct.unpack("I", raw_tcp_options[i+6:i+10])[0]
				print "  Timestamp"
				print "    TSval: " + str(ts_val)
				print "    TSecr: " + str(ts_ecr)
				i += 9
			#TODO: Other options
			i += 1
