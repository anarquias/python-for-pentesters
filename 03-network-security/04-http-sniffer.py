#!/usr/bin/env python
# Simple packet sniffer that parses HTTP packets and presents individual fields
# Does so by looking for TCP packets with port 80! Kinda naive
# Must be root
# References:
# TCP Header diagram:
#   https://nmap.org/book/images/hdr/MJB-TCP-Header-800x564.png

import binascii
import socket
import struct

ETH_LEN = 14	# Length of ethernet frame
big_line = "================================================================"
small_line = "----------------------------------------------------------------"

# Use packet interface, raw socket, tell kernel we want to use protocol 0x0800 = IP
# See /usr/include/linux/if_ether.h
rawSocket = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.htons(0x0800))

while True:
	pkt = rawSocket.recvfrom(2048)

	##########################################
	# IP Info 
	##########################################
	raw_ip_header = pkt[0][ETH_LEN:34] # IP Header is 20 bytes

	# Unpack to tuple, like: 
	# ('\x45', '\x00\x00Y\xde\x82@\x00\xff', 17, '\xf9\xff', '\xc0\xa8\x01m', '\xe0\x00\x00\xfb')
	# Don't care about first 12 bytes, since src/dest ip comes after
	ip_header = struct.unpack("!B8sB2s4s4s", raw_ip_header)

	protocol = ip_header[2]	# 9th byte indicates protocol
	if protocol != 6:
		#Skip if not TCP (protocol ID of TCP is 6)
		continue
	ihl = (ip_header[0] & 0x0F)*4	# IHL - Header length in words (1 nybble)
	
	##########################################
	# TCP Info
	##########################################
	raw_tcp_header = pkt[0][ETH_LEN+ihl:ETH_LEN+ihl+20] # Beginning of TCP Header computed using IHL

	# Unpack to tuple, like: (55101, 1900, 7202615, 1294816069, 65, 82, 17224, 8234, 8264)
	# Source port (2 bytes), dest port (2 bytes), seq num (4 bytes), ack num (4 bytes)
	# Offet (nybble), reserved (nybble), TCP Flags C E U A P R S F (1 bit ea, 1 byte total)
	# Window (2 bytes), Checksum (2 bytes), Urgent pointer (2 bytes)
	try:
		tcp_header = struct.unpack("!HHIIBBHHH", raw_tcp_header)
	except struct.error:
		print "Error while attempting to unpack tcp header!"
		print "".join(c.encode('hex') for c in raw_tcp_header)
		continue

	src_port = tcp_header[0]	# Source port (2 bytes)
	dst_port = tcp_header[1]	# Destination port (2 bytes)
	seq_num = tcp_header[2]		# Sequence number (4 bytes)
	ack_num = tcp_header[3]		# Acknowledgement number (4 bytes)
	offset = (tcp_header[4] >> 4)*4	# Offset - header length in words (1 nybble)

	if not src_port == 80 and not dst_port == 80:
		continue

	##########################################
	# HTTP Info
	##########################################
	http_payload = pkt[0][ETH_LEN+ihl+offset:]

	print big_line
	print "[IP] Source: " + socket.inet_ntoa(ip_header[4]),
	print ", Destination: " + socket.inet_ntoa(ip_header[5])
	print "Source Port: " + str(src_port)
	print "Destination Port: " + str(dst_port)
	print "Sequence Number: " + str(seq_num)
	print "Acknowledgement number: " + str(ack_num)
	print small_line
	print http_payload
	print small_line
